// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protorune.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:protorune.RuneId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RuneId {
    // message fields
    // @@protoc_insertion_point(field:protorune.RuneId.height)
    pub height: u32,
    // @@protoc_insertion_point(field:protorune.RuneId.txindex)
    pub txindex: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.RuneId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuneId {
    fn default() -> &'a RuneId {
        <RuneId as ::protobuf::Message>::default_instance()
    }
}

impl RuneId {
    pub fn new() -> RuneId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &RuneId| { &m.height },
            |m: &mut RuneId| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txindex",
            |m: &RuneId| { &m.txindex },
            |m: &mut RuneId| { &mut m.txindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuneId>(
            "RuneId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuneId {
    const NAME: &'static str = "RuneId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.height = is.read_uint32()?;
                },
                16 => {
                    self.txindex = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.height);
        }
        if self.txindex != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.txindex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.height != 0 {
            os.write_uint32(1, self.height)?;
        }
        if self.txindex != 0 {
            os.write_uint32(2, self.txindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuneId {
        RuneId::new()
    }

    fn clear(&mut self) {
        self.height = 0;
        self.txindex = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuneId {
        static instance: RuneId = RuneId {
            height: 0,
            txindex: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuneId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuneId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuneId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuneId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.Rune)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Rune {
    // message fields
    // @@protoc_insertion_point(field:protorune.Rune.runeId)
    pub runeId: ::protobuf::MessageField<RuneId>,
    // @@protoc_insertion_point(field:protorune.Rune.name)
    pub name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.Rune.divisibility)
    pub divisibility: u32,
    // @@protoc_insertion_point(field:protorune.Rune.spacers)
    pub spacers: u32,
    // @@protoc_insertion_point(field:protorune.Rune.symbol)
    pub symbol: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.Rune.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Rune {
    fn default() -> &'a Rune {
        <Rune as ::protobuf::Message>::default_instance()
    }
}

impl Rune {
    pub fn new() -> Rune {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RuneId>(
            "runeId",
            |m: &Rune| { &m.runeId },
            |m: &mut Rune| { &mut m.runeId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Rune| { &m.name },
            |m: &mut Rune| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "divisibility",
            |m: &Rune| { &m.divisibility },
            |m: &mut Rune| { &mut m.divisibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spacers",
            |m: &Rune| { &m.spacers },
            |m: &mut Rune| { &mut m.spacers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symbol",
            |m: &Rune| { &m.symbol },
            |m: &mut Rune| { &mut m.symbol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rune>(
            "Rune",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Rune {
    const NAME: &'static str = "Rune";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runeId)?;
                },
                18 => {
                    self.name = is.read_bytes()?;
                },
                24 => {
                    self.divisibility = is.read_uint32()?;
                },
                32 => {
                    self.spacers = is.read_uint32()?;
                },
                40 => {
                    self.symbol = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.runeId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.name);
        }
        if self.divisibility != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.divisibility);
        }
        if self.spacers != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.spacers);
        }
        if self.symbol != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.symbol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.runeId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_bytes(2, &self.name)?;
        }
        if self.divisibility != 0 {
            os.write_uint32(3, self.divisibility)?;
        }
        if self.spacers != 0 {
            os.write_uint32(4, self.spacers)?;
        }
        if self.symbol != 0 {
            os.write_uint32(5, self.symbol)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Rune {
        Rune::new()
    }

    fn clear(&mut self) {
        self.runeId.clear();
        self.name.clear();
        self.divisibility = 0;
        self.spacers = 0;
        self.symbol = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Rune {
        static instance: Rune = Rune {
            runeId: ::protobuf::MessageField::none(),
            name: ::std::vec::Vec::new(),
            divisibility: 0,
            spacers: 0,
            symbol: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Rune {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Rune").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Rune {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rune {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.BalanceSheetItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BalanceSheetItem {
    // message fields
    // @@protoc_insertion_point(field:protorune.BalanceSheetItem.rune)
    pub rune: ::protobuf::MessageField<Rune>,
    // @@protoc_insertion_point(field:protorune.BalanceSheetItem.balance)
    pub balance: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.BalanceSheetItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BalanceSheetItem {
    fn default() -> &'a BalanceSheetItem {
        <BalanceSheetItem as ::protobuf::Message>::default_instance()
    }
}

impl BalanceSheetItem {
    pub fn new() -> BalanceSheetItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rune>(
            "rune",
            |m: &BalanceSheetItem| { &m.rune },
            |m: &mut BalanceSheetItem| { &mut m.rune },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "balance",
            |m: &BalanceSheetItem| { &m.balance },
            |m: &mut BalanceSheetItem| { &mut m.balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BalanceSheetItem>(
            "BalanceSheetItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BalanceSheetItem {
    const NAME: &'static str = "BalanceSheetItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rune)?;
                },
                18 => {
                    self.balance = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rune.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rune.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.balance.is_empty() {
            os.write_bytes(2, &self.balance)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BalanceSheetItem {
        BalanceSheetItem::new()
    }

    fn clear(&mut self) {
        self.rune.clear();
        self.balance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BalanceSheetItem {
        static instance: BalanceSheetItem = BalanceSheetItem {
            rune: ::protobuf::MessageField::none(),
            balance: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BalanceSheetItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BalanceSheetItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BalanceSheetItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BalanceSheetItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.BalanceSheet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BalanceSheet {
    // message fields
    // @@protoc_insertion_point(field:protorune.BalanceSheet.entries)
    pub entries: ::std::vec::Vec<BalanceSheetItem>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.BalanceSheet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BalanceSheet {
    fn default() -> &'a BalanceSheet {
        <BalanceSheet as ::protobuf::Message>::default_instance()
    }
}

impl BalanceSheet {
    pub fn new() -> BalanceSheet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &BalanceSheet| { &m.entries },
            |m: &mut BalanceSheet| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BalanceSheet>(
            "BalanceSheet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BalanceSheet {
    const NAME: &'static str = "BalanceSheet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BalanceSheet {
        BalanceSheet::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BalanceSheet {
        static instance: BalanceSheet = BalanceSheet {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BalanceSheet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BalanceSheet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BalanceSheet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BalanceSheet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.Outpoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Outpoint {
    // message fields
    // @@protoc_insertion_point(field:protorune.Outpoint.txid)
    pub txid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.Outpoint.vout)
    pub vout: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.Outpoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Outpoint {
    fn default() -> &'a Outpoint {
        <Outpoint as ::protobuf::Message>::default_instance()
    }
}

impl Outpoint {
    pub fn new() -> Outpoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txid",
            |m: &Outpoint| { &m.txid },
            |m: &mut Outpoint| { &mut m.txid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vout",
            |m: &Outpoint| { &m.vout },
            |m: &mut Outpoint| { &mut m.vout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Outpoint>(
            "Outpoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Outpoint {
    const NAME: &'static str = "Outpoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txid = is.read_bytes()?;
                },
                16 => {
                    self.vout = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.vout);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.vout != 0 {
            os.write_uint32(2, self.vout)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Outpoint {
        Outpoint::new()
    }

    fn clear(&mut self) {
        self.txid.clear();
        self.vout = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Outpoint {
        static instance: Outpoint = Outpoint {
            txid: ::std::vec::Vec::new(),
            vout: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Outpoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Outpoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Outpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Outpoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.OutpointWithProtocol)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OutpointWithProtocol {
    // message fields
    // @@protoc_insertion_point(field:protorune.OutpointWithProtocol.txid)
    pub txid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.OutpointWithProtocol.vout)
    pub vout: u32,
    // @@protoc_insertion_point(field:protorune.OutpointWithProtocol.protocol)
    pub protocol: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.OutpointWithProtocol.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OutpointWithProtocol {
    fn default() -> &'a OutpointWithProtocol {
        <OutpointWithProtocol as ::protobuf::Message>::default_instance()
    }
}

impl OutpointWithProtocol {
    pub fn new() -> OutpointWithProtocol {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txid",
            |m: &OutpointWithProtocol| { &m.txid },
            |m: &mut OutpointWithProtocol| { &mut m.txid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vout",
            |m: &OutpointWithProtocol| { &m.vout },
            |m: &mut OutpointWithProtocol| { &mut m.vout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &OutpointWithProtocol| { &m.protocol },
            |m: &mut OutpointWithProtocol| { &mut m.protocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutpointWithProtocol>(
            "OutpointWithProtocol",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OutpointWithProtocol {
    const NAME: &'static str = "OutpointWithProtocol";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.txid = is.read_bytes()?;
                },
                16 => {
                    self.vout = is.read_uint32()?;
                },
                26 => {
                    self.protocol = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.vout);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.protocol);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.vout != 0 {
            os.write_uint32(2, self.vout)?;
        }
        if !self.protocol.is_empty() {
            os.write_bytes(3, &self.protocol)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OutpointWithProtocol {
        OutpointWithProtocol::new()
    }

    fn clear(&mut self) {
        self.txid.clear();
        self.vout = 0;
        self.protocol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OutpointWithProtocol {
        static instance: OutpointWithProtocol = OutpointWithProtocol {
            txid: ::std::vec::Vec::new(),
            vout: 0,
            protocol: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OutpointWithProtocol {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OutpointWithProtocol").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OutpointWithProtocol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutpointWithProtocol {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.Output)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Output {
    // message fields
    // @@protoc_insertion_point(field:protorune.Output.script)
    pub script: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.Output.value)
    pub value: u64,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.Output.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Output {
    fn default() -> &'a Output {
        <Output as ::protobuf::Message>::default_instance()
    }
}

impl Output {
    pub fn new() -> Output {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "script",
            |m: &Output| { &m.script },
            |m: &mut Output| { &mut m.script },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Output| { &m.value },
            |m: &mut Output| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Output>(
            "Output",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Output {
    const NAME: &'static str = "Output";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.script = is.read_bytes()?;
                },
                16 => {
                    self.value = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.script.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.script);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.script.is_empty() {
            os.write_bytes(1, &self.script)?;
        }
        if self.value != 0 {
            os.write_uint64(2, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Output {
        Output::new()
    }

    fn clear(&mut self) {
        self.script.clear();
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Output {
        static instance: Output = Output {
            script: ::std::vec::Vec::new(),
            value: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Output {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Output").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Output {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Output {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.OutpointResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OutpointResponse {
    // message fields
    // @@protoc_insertion_point(field:protorune.OutpointResponse.balances)
    pub balances: ::protobuf::MessageField<BalanceSheet>,
    // @@protoc_insertion_point(field:protorune.OutpointResponse.outpoint)
    pub outpoint: ::protobuf::MessageField<Outpoint>,
    // @@protoc_insertion_point(field:protorune.OutpointResponse.output)
    pub output: ::protobuf::MessageField<Output>,
    // @@protoc_insertion_point(field:protorune.OutpointResponse.height)
    pub height: u32,
    // @@protoc_insertion_point(field:protorune.OutpointResponse.txindex)
    pub txindex: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.OutpointResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OutpointResponse {
    fn default() -> &'a OutpointResponse {
        <OutpointResponse as ::protobuf::Message>::default_instance()
    }
}

impl OutpointResponse {
    pub fn new() -> OutpointResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BalanceSheet>(
            "balances",
            |m: &OutpointResponse| { &m.balances },
            |m: &mut OutpointResponse| { &mut m.balances },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Outpoint>(
            "outpoint",
            |m: &OutpointResponse| { &m.outpoint },
            |m: &mut OutpointResponse| { &mut m.outpoint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Output>(
            "output",
            |m: &OutpointResponse| { &m.output },
            |m: &mut OutpointResponse| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &OutpointResponse| { &m.height },
            |m: &mut OutpointResponse| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "txindex",
            |m: &OutpointResponse| { &m.txindex },
            |m: &mut OutpointResponse| { &mut m.txindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutpointResponse>(
            "OutpointResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OutpointResponse {
    const NAME: &'static str = "OutpointResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.balances)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.outpoint)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.output)?;
                },
                32 => {
                    self.height = is.read_uint32()?;
                },
                40 => {
                    self.txindex = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.balances.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.outpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.height);
        }
        if self.txindex != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.txindex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.balances.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.outpoint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.output.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.height != 0 {
            os.write_uint32(4, self.height)?;
        }
        if self.txindex != 0 {
            os.write_uint32(5, self.txindex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OutpointResponse {
        OutpointResponse::new()
    }

    fn clear(&mut self) {
        self.balances.clear();
        self.outpoint.clear();
        self.output.clear();
        self.height = 0;
        self.txindex = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OutpointResponse {
        static instance: OutpointResponse = OutpointResponse {
            balances: ::protobuf::MessageField::none(),
            outpoint: ::protobuf::MessageField::none(),
            output: ::protobuf::MessageField::none(),
            height: 0,
            txindex: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OutpointResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OutpointResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OutpointResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutpointResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.PaginationInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PaginationInput {
    // message fields
    // @@protoc_insertion_point(field:protorune.PaginationInput.start)
    pub start: u32,
    // @@protoc_insertion_point(field:protorune.PaginationInput.end)
    pub end: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.PaginationInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaginationInput {
    fn default() -> &'a PaginationInput {
        <PaginationInput as ::protobuf::Message>::default_instance()
    }
}

impl PaginationInput {
    pub fn new() -> PaginationInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start",
            |m: &PaginationInput| { &m.start },
            |m: &mut PaginationInput| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end",
            |m: &PaginationInput| { &m.end },
            |m: &mut PaginationInput| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaginationInput>(
            "PaginationInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaginationInput {
    const NAME: &'static str = "PaginationInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = is.read_uint32()?;
                },
                16 => {
                    self.end = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.start != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.start);
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.start != 0 {
            os.write_uint32(1, self.start)?;
        }
        if self.end != 0 {
            os.write_uint32(2, self.end)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaginationInput {
        PaginationInput::new()
    }

    fn clear(&mut self) {
        self.start = 0;
        self.end = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaginationInput {
        static instance: PaginationInput = PaginationInput {
            start: 0,
            end: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaginationInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaginationInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaginationInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaginationInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.WalletRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WalletRequest {
    // message fields
    // @@protoc_insertion_point(field:protorune.WalletRequest.wallet)
    pub wallet: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.WalletRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WalletRequest {
    fn default() -> &'a WalletRequest {
        <WalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl WalletRequest {
    pub fn new() -> WalletRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wallet",
            |m: &WalletRequest| { &m.wallet },
            |m: &mut WalletRequest| { &mut m.wallet },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WalletRequest>(
            "WalletRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WalletRequest {
    const NAME: &'static str = "WalletRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wallet = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wallet.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wallet.is_empty() {
            os.write_bytes(1, &self.wallet)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WalletRequest {
        WalletRequest::new()
    }

    fn clear(&mut self) {
        self.wallet.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WalletRequest {
        static instance: WalletRequest = WalletRequest {
            wallet: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WalletRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WalletRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.WalletResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WalletResponse {
    // message fields
    // @@protoc_insertion_point(field:protorune.WalletResponse.outpoints)
    pub outpoints: ::std::vec::Vec<OutpointResponse>,
    // @@protoc_insertion_point(field:protorune.WalletResponse.balances)
    pub balances: ::protobuf::MessageField<BalanceSheet>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.WalletResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WalletResponse {
    fn default() -> &'a WalletResponse {
        <WalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl WalletResponse {
    pub fn new() -> WalletResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outpoints",
            |m: &WalletResponse| { &m.outpoints },
            |m: &mut WalletResponse| { &mut m.outpoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BalanceSheet>(
            "balances",
            |m: &WalletResponse| { &m.balances },
            |m: &mut WalletResponse| { &mut m.balances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WalletResponse>(
            "WalletResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WalletResponse {
    const NAME: &'static str = "WalletResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.outpoints.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.balances)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.outpoints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.balances.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.outpoints {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.balances.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WalletResponse {
        WalletResponse::new()
    }

    fn clear(&mut self) {
        self.outpoints.clear();
        self.balances.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WalletResponse {
        static instance: WalletResponse = WalletResponse {
            outpoints: ::std::vec::Vec::new(),
            balances: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WalletResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WalletResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.ProtorunesWalletRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtorunesWalletRequest {
    // message fields
    // @@protoc_insertion_point(field:protorune.ProtorunesWalletRequest.wallet)
    pub wallet: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.ProtorunesWalletRequest.protocol_tag)
    pub protocol_tag: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.ProtorunesWalletRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtorunesWalletRequest {
    fn default() -> &'a ProtorunesWalletRequest {
        <ProtorunesWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl ProtorunesWalletRequest {
    pub fn new() -> ProtorunesWalletRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wallet",
            |m: &ProtorunesWalletRequest| { &m.wallet },
            |m: &mut ProtorunesWalletRequest| { &mut m.wallet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol_tag",
            |m: &ProtorunesWalletRequest| { &m.protocol_tag },
            |m: &mut ProtorunesWalletRequest| { &mut m.protocol_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtorunesWalletRequest>(
            "ProtorunesWalletRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtorunesWalletRequest {
    const NAME: &'static str = "ProtorunesWalletRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wallet = is.read_bytes()?;
                },
                18 => {
                    self.protocol_tag = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wallet.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet);
        }
        if !self.protocol_tag.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.protocol_tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wallet.is_empty() {
            os.write_bytes(1, &self.wallet)?;
        }
        if !self.protocol_tag.is_empty() {
            os.write_bytes(2, &self.protocol_tag)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtorunesWalletRequest {
        ProtorunesWalletRequest::new()
    }

    fn clear(&mut self) {
        self.wallet.clear();
        self.protocol_tag.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtorunesWalletRequest {
        static instance: ProtorunesWalletRequest = ProtorunesWalletRequest {
            wallet: ::std::vec::Vec::new(),
            protocol_tag: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtorunesWalletRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtorunesWalletRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtorunesWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtorunesWalletRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.RunesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RunesResponse {
    // message fields
    // @@protoc_insertion_point(field:protorune.RunesResponse.runes)
    pub runes: ::std::vec::Vec<Rune>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.RunesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RunesResponse {
    fn default() -> &'a RunesResponse {
        <RunesResponse as ::protobuf::Message>::default_instance()
    }
}

impl RunesResponse {
    pub fn new() -> RunesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "runes",
            |m: &RunesResponse| { &m.runes },
            |m: &mut RunesResponse| { &mut m.runes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RunesResponse>(
            "RunesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RunesResponse {
    const NAME: &'static str = "RunesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.runes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.runes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.runes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RunesResponse {
        RunesResponse::new()
    }

    fn clear(&mut self) {
        self.runes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RunesResponse {
        static instance: RunesResponse = RunesResponse {
            runes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RunesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RunesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RunesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.ProtoBurn)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoBurn {
    // message fields
    // @@protoc_insertion_point(field:protorune.ProtoBurn.protocol_tag)
    pub protocol_tag: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.ProtoBurn.pointer)
    pub pointer: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.ProtoBurn.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoBurn {
    fn default() -> &'a ProtoBurn {
        <ProtoBurn as ::protobuf::Message>::default_instance()
    }
}

impl ProtoBurn {
    pub fn new() -> ProtoBurn {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol_tag",
            |m: &ProtoBurn| { &m.protocol_tag },
            |m: &mut ProtoBurn| { &mut m.protocol_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pointer",
            |m: &ProtoBurn| { &m.pointer },
            |m: &mut ProtoBurn| { &mut m.pointer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoBurn>(
            "ProtoBurn",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoBurn {
    const NAME: &'static str = "ProtoBurn";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.protocol_tag = is.read_bytes()?;
                },
                16 => {
                    self.pointer = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.protocol_tag.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.protocol_tag);
        }
        if self.pointer != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.pointer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.protocol_tag.is_empty() {
            os.write_bytes(1, &self.protocol_tag)?;
        }
        if self.pointer != 0 {
            os.write_uint32(2, self.pointer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoBurn {
        ProtoBurn::new()
    }

    fn clear(&mut self) {
        self.protocol_tag.clear();
        self.pointer = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoBurn {
        static instance: ProtoBurn = ProtoBurn {
            protocol_tag: ::std::vec::Vec::new(),
            pointer: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoBurn {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoBurn").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoBurn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoBurn {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.uint128)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Uint128 {
    // message fields
    // @@protoc_insertion_point(field:protorune.uint128.lo)
    pub lo: u64,
    // @@protoc_insertion_point(field:protorune.uint128.hi)
    pub hi: u64,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.uint128.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Uint128 {
    fn default() -> &'a Uint128 {
        <Uint128 as ::protobuf::Message>::default_instance()
    }
}

impl Uint128 {
    pub fn new() -> Uint128 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lo",
            |m: &Uint128| { &m.lo },
            |m: &mut Uint128| { &mut m.lo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hi",
            |m: &Uint128| { &m.hi },
            |m: &mut Uint128| { &mut m.hi },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Uint128>(
            "uint128",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Uint128 {
    const NAME: &'static str = "uint128";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lo = is.read_uint64()?;
                },
                16 => {
                    self.hi = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.lo != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.lo);
        }
        if self.hi != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.hi);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.lo != 0 {
            os.write_uint64(1, self.lo)?;
        }
        if self.hi != 0 {
            os.write_uint64(2, self.hi)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Uint128 {
        Uint128::new()
    }

    fn clear(&mut self) {
        self.lo = 0;
        self.hi = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Uint128 {
        static instance: Uint128 = Uint128 {
            lo: 0,
            hi: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Uint128 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("uint128").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Uint128 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uint128 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.Clause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Clause {
    // message fields
    // @@protoc_insertion_point(field:protorune.Clause.rune)
    pub rune: ::protobuf::MessageField<RuneId>,
    // @@protoc_insertion_point(field:protorune.Clause.amount)
    pub amount: ::protobuf::MessageField<Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.Clause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Clause {
    fn default() -> &'a Clause {
        <Clause as ::protobuf::Message>::default_instance()
    }
}

impl Clause {
    pub fn new() -> Clause {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RuneId>(
            "rune",
            |m: &Clause| { &m.rune },
            |m: &mut Clause| { &mut m.rune },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Uint128>(
            "amount",
            |m: &Clause| { &m.amount },
            |m: &mut Clause| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Clause>(
            "Clause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Clause {
    const NAME: &'static str = "Clause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rune)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amount)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rune.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rune.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Clause {
        Clause::new()
    }

    fn clear(&mut self) {
        self.rune.clear();
        self.amount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Clause {
        static instance: Clause = Clause {
            rune: ::protobuf::MessageField::none(),
            amount: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Clause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Clause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Clause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Clause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.Predicate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Predicate {
    // message fields
    // @@protoc_insertion_point(field:protorune.Predicate.clauses)
    pub clauses: ::std::vec::Vec<Clause>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.Predicate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Predicate {
    fn default() -> &'a Predicate {
        <Predicate as ::protobuf::Message>::default_instance()
    }
}

impl Predicate {
    pub fn new() -> Predicate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clauses",
            |m: &Predicate| { &m.clauses },
            |m: &mut Predicate| { &mut m.clauses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Predicate>(
            "Predicate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Predicate {
    const NAME: &'static str = "Predicate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clauses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.clauses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.clauses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Predicate {
        Predicate::new()
    }

    fn clear(&mut self) {
        self.clauses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Predicate {
        static instance: Predicate = Predicate {
            clauses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Predicate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Predicate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Predicate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Predicate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.ProtoMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoMessage {
    // message fields
    // @@protoc_insertion_point(field:protorune.ProtoMessage.calldata)
    pub calldata: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:protorune.ProtoMessage.predicate)
    pub predicate: ::protobuf::MessageField<Predicate>,
    // @@protoc_insertion_point(field:protorune.ProtoMessage.pointer)
    pub pointer: u32,
    // @@protoc_insertion_point(field:protorune.ProtoMessage.refund_pointer)
    pub refund_pointer: u32,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.ProtoMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoMessage {
    fn default() -> &'a ProtoMessage {
        <ProtoMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProtoMessage {
    pub fn new() -> ProtoMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "calldata",
            |m: &ProtoMessage| { &m.calldata },
            |m: &mut ProtoMessage| { &mut m.calldata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Predicate>(
            "predicate",
            |m: &ProtoMessage| { &m.predicate },
            |m: &mut ProtoMessage| { &mut m.predicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pointer",
            |m: &ProtoMessage| { &m.pointer },
            |m: &mut ProtoMessage| { &mut m.pointer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "refund_pointer",
            |m: &ProtoMessage| { &m.refund_pointer },
            |m: &mut ProtoMessage| { &mut m.refund_pointer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoMessage>(
            "ProtoMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoMessage {
    const NAME: &'static str = "ProtoMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.calldata = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.predicate)?;
                },
                24 => {
                    self.pointer = is.read_uint32()?;
                },
                32 => {
                    self.refund_pointer = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.calldata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.calldata);
        }
        if let Some(v) = self.predicate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.pointer != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.pointer);
        }
        if self.refund_pointer != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.refund_pointer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.calldata.is_empty() {
            os.write_bytes(1, &self.calldata)?;
        }
        if let Some(v) = self.predicate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.pointer != 0 {
            os.write_uint32(3, self.pointer)?;
        }
        if self.refund_pointer != 0 {
            os.write_uint32(4, self.refund_pointer)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoMessage {
        ProtoMessage::new()
    }

    fn clear(&mut self) {
        self.calldata.clear();
        self.predicate.clear();
        self.pointer = 0;
        self.refund_pointer = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoMessage {
        static instance: ProtoMessage = ProtoMessage {
            calldata: ::std::vec::Vec::new(),
            predicate: ::protobuf::MessageField::none(),
            pointer: 0,
            refund_pointer: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.RuntimeInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RuntimeInput {
    // message fields
    // @@protoc_insertion_point(field:protorune.RuntimeInput.protocol_tag)
    pub protocol_tag: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.RuntimeInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuntimeInput {
    fn default() -> &'a RuntimeInput {
        <RuntimeInput as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeInput {
    pub fn new() -> RuntimeInput {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol_tag",
            |m: &RuntimeInput| { &m.protocol_tag },
            |m: &mut RuntimeInput| { &mut m.protocol_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeInput>(
            "RuntimeInput",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuntimeInput {
    const NAME: &'static str = "RuntimeInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.protocol_tag = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.protocol_tag.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.protocol_tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.protocol_tag.is_empty() {
            os.write_bytes(1, &self.protocol_tag)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuntimeInput {
        RuntimeInput::new()
    }

    fn clear(&mut self) {
        self.protocol_tag.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuntimeInput {
        static instance: RuntimeInput = RuntimeInput {
            protocol_tag: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuntimeInput {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuntimeInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuntimeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeInput {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:protorune.Runtime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Runtime {
    // message fields
    // @@protoc_insertion_point(field:protorune.Runtime.balances)
    pub balances: ::protobuf::MessageField<BalanceSheet>,
    // special fields
    // @@protoc_insertion_point(special_field:protorune.Runtime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Runtime {
    fn default() -> &'a Runtime {
        <Runtime as ::protobuf::Message>::default_instance()
    }
}

impl Runtime {
    pub fn new() -> Runtime {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BalanceSheet>(
            "balances",
            |m: &Runtime| { &m.balances },
            |m: &mut Runtime| { &mut m.balances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Runtime>(
            "Runtime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Runtime {
    const NAME: &'static str = "Runtime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.balances)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.balances.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.balances.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Runtime {
        Runtime::new()
    }

    fn clear(&mut self) {
        self.balances.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Runtime {
        static instance: Runtime = Runtime {
            balances: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Runtime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Runtime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Runtime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Runtime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fprotorune.proto\x12\tprotorune\":\n\x06RuneId\x12\x16\n\x06height\
    \x18\x01\x20\x01(\rR\x06height\x12\x18\n\x07txindex\x18\x02\x20\x01(\rR\
    \x07txindex\"\x9b\x01\n\x04Rune\x12)\n\x06runeId\x18\x01\x20\x01(\x0b2\
    \x11.protorune.RuneIdR\x06runeId\x12\x12\n\x04name\x18\x02\x20\x01(\x0cR\
    \x04name\x12\"\n\x0cdivisibility\x18\x03\x20\x01(\rR\x0cdivisibility\x12\
    \x18\n\x07spacers\x18\x04\x20\x01(\rR\x07spacers\x12\x16\n\x06symbol\x18\
    \x05\x20\x01(\rR\x06symbol\"Q\n\x10BalanceSheetItem\x12#\n\x04rune\x18\
    \x01\x20\x01(\x0b2\x0f.protorune.RuneR\x04rune\x12\x18\n\x07balance\x18\
    \x02\x20\x01(\x0cR\x07balance\"E\n\x0cBalanceSheet\x125\n\x07entries\x18\
    \x01\x20\x03(\x0b2\x1b.protorune.BalanceSheetItemR\x07entries\"2\n\x08Ou\
    tpoint\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\x04txid\x12\x12\n\x04vout\
    \x18\x02\x20\x01(\rR\x04vout\"Z\n\x14OutpointWithProtocol\x12\x12\n\x04t\
    xid\x18\x01\x20\x01(\x0cR\x04txid\x12\x12\n\x04vout\x18\x02\x20\x01(\rR\
    \x04vout\x12\x1a\n\x08protocol\x18\x03\x20\x01(\x0cR\x08protocol\"6\n\
    \x06Output\x12\x16\n\x06script\x18\x01\x20\x01(\x0cR\x06script\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x04R\x05value\"\xd5\x01\n\x10OutpointResponse\
    \x123\n\x08balances\x18\x01\x20\x01(\x0b2\x17.protorune.BalanceSheetR\
    \x08balances\x12/\n\x08outpoint\x18\x02\x20\x01(\x0b2\x13.protorune.Outp\
    ointR\x08outpoint\x12)\n\x06output\x18\x03\x20\x01(\x0b2\x11.protorune.O\
    utputR\x06output\x12\x16\n\x06height\x18\x04\x20\x01(\rR\x06height\x12\
    \x18\n\x07txindex\x18\x05\x20\x01(\rR\x07txindex\"9\n\x0fPaginationInput\
    \x12\x14\n\x05start\x18\x01\x20\x01(\rR\x05start\x12\x10\n\x03end\x18\
    \x02\x20\x01(\rR\x03end\"'\n\rWalletRequest\x12\x16\n\x06wallet\x18\x01\
    \x20\x01(\x0cR\x06wallet\"\x80\x01\n\x0eWalletResponse\x129\n\toutpoints\
    \x18\x01\x20\x03(\x0b2\x1b.protorune.OutpointResponseR\toutpoints\x123\n\
    \x08balances\x18\x02\x20\x01(\x0b2\x17.protorune.BalanceSheetR\x08balanc\
    es\"T\n\x17ProtorunesWalletRequest\x12\x16\n\x06wallet\x18\x01\x20\x01(\
    \x0cR\x06wallet\x12!\n\x0cprotocol_tag\x18\x02\x20\x01(\x0cR\x0bprotocol\
    Tag\"6\n\rRunesResponse\x12%\n\x05runes\x18\x01\x20\x03(\x0b2\x0f.protor\
    une.RuneR\x05runes\"H\n\tProtoBurn\x12!\n\x0cprotocol_tag\x18\x01\x20\
    \x01(\x0cR\x0bprotocolTag\x12\x18\n\x07pointer\x18\x02\x20\x01(\rR\x07po\
    inter\")\n\x07uint128\x12\x0e\n\x02lo\x18\x01\x20\x01(\x04R\x02lo\x12\
    \x0e\n\x02hi\x18\x02\x20\x01(\x04R\x02hi\"[\n\x06Clause\x12%\n\x04rune\
    \x18\x01\x20\x01(\x0b2\x11.protorune.RuneIdR\x04rune\x12*\n\x06amount\
    \x18\x02\x20\x01(\x0b2\x12.protorune.uint128R\x06amount\"8\n\tPredicate\
    \x12+\n\x07clauses\x18\x01\x20\x03(\x0b2\x11.protorune.ClauseR\x07clause\
    s\"\x9f\x01\n\x0cProtoMessage\x12\x1a\n\x08calldata\x18\x01\x20\x01(\x0c\
    R\x08calldata\x122\n\tpredicate\x18\x02\x20\x01(\x0b2\x14.protorune.Pred\
    icateR\tpredicate\x12\x18\n\x07pointer\x18\x03\x20\x01(\rR\x07pointer\
    \x12%\n\x0erefund_pointer\x18\x04\x20\x01(\rR\rrefundPointer\"1\n\x0cRun\
    timeInput\x12!\n\x0cprotocol_tag\x18\x01\x20\x01(\x0cR\x0bprotocolTag\">\
    \n\x07Runtime\x123\n\x08balances\x18\x01\x20\x01(\x0b2\x17.protorune.Bal\
    anceSheetR\x08balancesb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(20);
            messages.push(RuneId::generated_message_descriptor_data());
            messages.push(Rune::generated_message_descriptor_data());
            messages.push(BalanceSheetItem::generated_message_descriptor_data());
            messages.push(BalanceSheet::generated_message_descriptor_data());
            messages.push(Outpoint::generated_message_descriptor_data());
            messages.push(OutpointWithProtocol::generated_message_descriptor_data());
            messages.push(Output::generated_message_descriptor_data());
            messages.push(OutpointResponse::generated_message_descriptor_data());
            messages.push(PaginationInput::generated_message_descriptor_data());
            messages.push(WalletRequest::generated_message_descriptor_data());
            messages.push(WalletResponse::generated_message_descriptor_data());
            messages.push(ProtorunesWalletRequest::generated_message_descriptor_data());
            messages.push(RunesResponse::generated_message_descriptor_data());
            messages.push(ProtoBurn::generated_message_descriptor_data());
            messages.push(Uint128::generated_message_descriptor_data());
            messages.push(Clause::generated_message_descriptor_data());
            messages.push(Predicate::generated_message_descriptor_data());
            messages.push(ProtoMessage::generated_message_descriptor_data());
            messages.push(RuntimeInput::generated_message_descriptor_data());
            messages.push(Runtime::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
